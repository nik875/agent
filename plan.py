from collections import deque
from llm import LLMAgent

class PlanningModule:
    def __init__(self, api_key):
        """
        Initialize the PlanningModule with a generator (LLMAgent) and a critic (LLMAgent).
        """
        self.generator = LLMAgent(api_key)
        self.generator.create_agent("Generate thorough, step-by-step, bite-sized plans to accomplish high-level goals.")

        self.critic = LLMAgent(api_key)
        self.critic.create_agent("Generate constructive criticisms of plans, and strive to make them more logical, specific, and achievable.")

        # Create instance variable for objective
        self.objective = None

        # Create an empty plan queue
        self.plan = deque()

    def generate_plan(self, objective):
        """
        Given a high-level objective, generate and save a series of concrete, tangible steps.
        """
        # Save the objective as an instance variable
        self.objective = objective

        # Construct a detailed and clear prompt for the generator to create a plan
        prompt = f"Generate a detailed and easy-to-follow plan to accomplish the following objective: '{objective}'. Each step should be small and easy to complete. A longer, more specific plan is preferred over a short, unclear one. The plan should be structured as follows:\n1. Step 1: [Your instruction here]\n2. Step 2: [Your instruction here]\n3. Step 3: [Your instruction here]\n\nProvide the plan ONLY in the requested format, and do not include any additional information or content."

        # Use the generator to create a plan
        plan_description = self.generator.prompt_agent(prompt)

        # Parse the plan description, remove line numbers, and add each part to the plan deque
        parsed_plan = [line.split(". ", 1)[1] for line in plan_description.strip().split('\n')]
        self.plan = deque(parsed_plan)

    def next_step(self):
        """
        Return the next step of the plan or None if the plan is empty.
        """
        if self.plan:
            return self.plan[0]
        else:
            return None

    def feedback(self, text):
        """
        Given real-world results of following a step, ask the critic for feedback.
        """
        current_step = self.plan[0]

        # Construct a prompt for the critic using the saved objective
        prompt = f"Your overarching goal is: {self.objective}\nCurrent Plan:\n{'; '.join(self.plan)}\n\nCurrent Step:\n{current_step}\n\nReal-world Result:\n{text}\n\nProvide constructive feedback to help improve the plan. Specifically, consider the following:\n1. Are we moving in the right direction to achieve the objective?\n2. If not, what adjustments can be made to the current plan to make it more effective?\n\nGenerate feedback in the following format: 'STEP_COMPLETED: <y/n>. FEEDBACK: <feedback here>'"

        # Ask the critic for feedback on the real-world result
        feedback_text = self.critic.prompt_agent(prompt)

        # Parse the feedback
        step_completion, critic_feedback = self.parse_feedback(feedback_text)

        if step_completion == "y":
            # If the step was completed, remove the current step from the plan
            self.plan.popleft()
        else:
            # If the step was not completed as per critic feedback, revise the plan
            self.revise_plan(critic_feedback)

        return feedback_text

    def revise_plan(self, feedback):
        """
        Generate a new, revised plan based on feedback and the current plan.
        """
        current_objective = f"Your overarching goal is: {self.objective}"
    
        # Construct a detailed and clear prompt for the generator to create a revised plan
        prompt = f"{current_objective}\nCurrent Plan:\n{'; '.join(self.plan)}\n\nGiven feedback: {feedback}\n\nGenerate a revised plan to make progress toward the objective. Each step should be small, easy to complete, and contribute to achieving the overarching goal. The plan should be structured as follows:\n1. Step 1: [Your instruction here]\n2. Step 2: [Your instruction here]\n3. Step 3: [Your instruction here]\n\nProvide the revised plan ONLY in the requested format, and do not include any additional information or content."

        # Use the generator to create a revised plan
        revised_plan = self.generator.prompt_agent(prompt)

        # Update the plan with the revised steps
        parsed_plan = [line.split(". ", 1)[1] for line in revised_plan.strip().split('\n')]
        self.plan = deque(parsed_plan)

    def parse_feedback(self, feedback_text):
        """
        Parse feedback generated by the critic into step_completion and feedback_text.
        """
        feedback_parts = feedback_text.split(": ")
        step_completion = feedback_parts[1].strip()
        feedback_text = feedback_parts[2].strip()

        return step_completion, feedback_text
